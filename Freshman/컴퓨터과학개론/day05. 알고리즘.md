## 🧑‍💻 알고리즘 (Algorithm)

### 1. 알고리즘이란?
*   주어진 문제를 풀기 위한 명령어들을 단계적으로 나열한 것입니다.

#### 알고리즘의 5가지 중요한 속성 (명세)
1.  **입출력**: 0개 이상의 외부 입력을 받아 1개 이상의 출력을 생성해야 합니다.
2.  **명확성**: 각 명령은 모호하지 않고 단순 명확해야 합니다.
3.  **유한성**: 한정된 수의 단계를 거친 후에는 반드시 종료해야 합니다.
4.  **유효성**: 모든 명령은 컴퓨터에서 실행할 수 있어야 합니다.
5.  **실용적 측면**: 효율적이어야 합니다.

#### 알고리즘 생성 단계
`설계 (Design)` -> `표현/기술 (Representation/Description)` -> `정확성 검증 (Correctness Verification)` -> `효율성 분석 (Efficiency Analysis)`

---

### 2. 알고리즘 설계 패러다임

#### 1) 분할 정복 (Divide and Conquer) 쪼개고 정복하고 결합
*   순환적으로 (recursively) 문제를 푸는 하향식 (top-down) 접근 방법입니다.
*   문제의 입력을 더 이상 나눌 수 없을 때까지 2개 이상의 작은 문제로 순환적으로 분할하고, 분할된 문제들을 각각 해결한 후, 이들의 해를 결합하여 원래 문제의 해를 구합니다.
*   분할된 작은 문제는 원래 문제와 동일하지만 입력 크기만 작아지며, 서로 독립적입니다.
*   **방법**: 분할 (Divide) -> 정복 (Conquer) -> 결합 (Combine)
*   **예시**: 퀵 정렬 (Quick Sort), 합병 정렬 (Merge Sort), 이진 탐색 (Binary Search)

#### 2) 동적 프로그래밍 (Dynamic Programming) 점화식 계산
*   최적화 문제 (최댓값, 최솟값)의 해를 구하기 위한 상향식 (bottom-up) 접근 방법입니다.
*   **예시**: 플로이드-워셜 알고리즘 (모든 정점 간의 최단 경로를 구하는 알고리즘)

#### 3) 욕심쟁이 (Greedy) / 탐욕적 방법 ✨
*   해를 구하는 일련의 선택 과정마다 전후 단계의 선택과는 상관없이 각 단계에서 가장 최선이라고 여겨지는 국부적인 최적해를 선택하여 결과적으로 전체적인 최적화를 얻을 수 있을 것이라고 희망하는 방법입니다.
*   **예시**: 거스름돈 문제, 배낭 문제

    *   **거스름돈 문제**:
        *   고객에게 돌려줄 거스름돈이 770원이고 동전의 종류가 500원, 100원, 50원, 10원일 때, 고객이 받을 동전의 개수를 최소로 하면서 거스름돈을 돌려주는 방법.
        *   770원: 500원 1개 -> 남은 돈 270원
        *   270원: 100원 2개 -> 남은 돈 70원
        *   70원: 50원 1개 -> 남은 돈 20원
        *   20원: 10원 2개 -> 남은 돈 0원 (총 1+2+1+2 = 6개)
    *   **배낭 문제**:
        *   최대 용량이 M인 하나의 배낭과 n개의 물체가 주어집니다. 각 물체 i는 물체의 무게 `w`와 해당 물체를 배낭에 넣었을 때 얻을 수 있는 이익 `P`를 가집니다. 배낭에 담을 물체를 선택하여 얻을 수 있는 총 이익을 최대화하는 문제입니다.

---

### 3. 알고리즘 분석

#### 1) 정확성 분석
*   유효한 입력에 대해 유한 시간 내에 정확한 결과를 생성하는지 여부를 분석합니다.

#### 2) 효율성 분석
*   알고리즘 수행에 필요한 컴퓨터 자원(메모리, 시간)의 양을 측정합니다.
    *   **공간 복잡도 (Space Complexity)**: 알고리즘이 실행되는 동안 사용하는 메모리의 양입니다. `정적 공간 (fixed part)` + `동적 공간 (variable part)`.
    *   **시간 복잡도 (Time Complexity)**: 알고리즘이 실행되는 데 걸리는 시간입니다.
        *   알고리즘에서 수행되는 단위 연산의 수행 횟수를 모두 더한 값입니다.
        *   입력으로 제공되는 데이터의 크기가 증가하면 수행 시간도 증가하므로, 입력 크기의 함수로 표현됩니다.
        *   입력 데이터의 상태에 따라 달라질 수 있으므로, `평균 수행 시간`, `최선 수행 시간`, `최악 수행 시간`으로 구분하여 분석합니다.

#### 점근 성능 (Asymptotic Performance)
*   입력 크기 `n`이 충분히 커짐에 따라 결정되는 성능입니다.
*   계수 없이 최고차항만을 이용해서 간략히 표현하는 성능입니다.

*   **Big-Oh (O) - 점근적 상한**: 함수의 증가율이 특정 함수보다 작거나 같다는 것을 나타냅니다. (최악의 경우 성능)
*   **Big-Omega (Ω) - 점근적 하한**: 함수의 증가율이 특정 함수보다 크거나 같다는 것을 나타냅니다. (최선의 경우 성능)
*   **Big-Theta (Θ) - 점근적 상하한**: 함수의 증가율이 특정 함수와 동일하다는 것을 나타냅니다. (평균의 경우 성능)

---

### 4. 정렬 알고리즘 (Sorting Algorithms) 🔢
*   데이터를 특정 순서(오름차순, 내림차순)로 재배열하는 알고리즘입니다.

#### 분류
*   **내부 정렬 (Internal Sort)**: 모든 데이터를 주기억장치에 올려놓고 정렬합니다.
*   **외부 정렬 (External Sort)**: 데이터 양이 많아 주기억장치에 모두 올릴 수 없을 때 보조기억장치를 사용하여 정렬합니다.

#### 내부 정렬 (비교 기반)
*   **선택 정렬 (Selection Sort)**: `O(n²)` - 주어진 데이터 중에서 가장 작은/큰 값부터 차례대로 선택하여 나열하는 정렬 방식입니다.
*   **버블 정렬 (Bubble Sort)**: `O(n²)` - 왼쪽에서부터 모든 인접한 두 데이터를 차례대로 비교하여 왼쪽의 값이 더 큰 경우(오름차순 기준) 오른쪽 값과 자리를 바꾸는 과정을 반복합니다.
*   **삽입 정렬 (Insertion Sort)**: `O(n²)` - 주어진 데이터를 하나씩 뽑은 후, 이미 나열된 데이터들이 항상 정렬된 형태를 가지도록 뽑은 데이터를 올바른 위치에 삽입하여 나열하는 방식입니다.
*   **퀵 정렬 (Quick Sort)**: `O(n log n)` - 분할 정복 방식을 사용하는 효율적인 정렬 알고리즘입니다.
*   **합병 정렬 (Merge Sort)**: `O(n log n)` - 분할 정복 방식을 사용하는 효율적인 정렬 알고리즘입니다.

#### 내부 정렬 (분포 기반)
*   **계수 정렬 (Counting Sort)**: `O(n)` - 데이터 값의 범위가 작을 때 사용하며, 각 숫자가 몇 번 나왔는지 세어 정렬합니다.
*   **기수 정렬 (Radix Sort)**: `O(n)` - 자리수를 기준으로 정렬하며, 비교 연산 없이 수행됩니다.

---