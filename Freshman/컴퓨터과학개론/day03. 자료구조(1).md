## 📚 자료구조 핵심 개념 정리

### 1. 자료구조 기본 개념

*   **추상화 (Abstraction)**
    *   공통적인 개념을 추출하여 같은 종류의 다양한 객체를 정의하는 과정입니다. (예: 수학적 수식, 프로그래밍 언어 등)
*   **자료의 추상화**
    *   다양한 객체를 컴퓨터에서 표현하고 활용하기 위해 필요한 데이터의 구조에서 공통의 특징만을 뽑아 정의한 것입니다.
*   **구조화 (Structuring)**
    *   자료의 추상화와 구조화가 적절히 이루어지지 못할 경우, 소프트웨어는 다음과 같은 문제에 직면할 수 있습니다.
        *   비효율적인 개발
        *   비효율적인 수행
        *   소프트웨어 확장성 문제
        *   소프트웨어 유지보수 문제
*   **미리 정의된 자료구조 (Predefined Data Structures)**
    *   프로그래밍 언어에서 기본적으로 제공하는 자료구조입니다.
    *   프로그래밍 설계나 컴파일러 구현 단계에서 정의되어 개발자에게 제공됩니다. (예: 정수형, 배열 등)
*   **사용자 정의 자료구조 (User-Defined Data Structures)**
    *   개발자가 직접 정의하여 사용하는 자료구조입니다.
    *   소프트웨어 개발 과정에서 필요에 따라 생성됩니다. (예: 리스트, 스택, 큐, 트리, 그래프 등)

---

### 2. 배열 (Array)

*   **정의**
    *   동일한 자료형을 갖는 여러 개의 데이터를 동일한 변수 이름의 공간에 **일렬로 저장**하는 자료 집합체입니다.
    *   **원소(요소)**: 자료 집합체에서 각 항목의 값, 즉 실제 데이터를 의미합니다.
    *   **인덱스(첨자)**: 자료 집합체에서 각 원소가 저장된 공간에 접근하기 위한 고유한 번호입니다.
*   **개념**
    *   가장 간단한 형태의 자료구조로, 하나의 인덱스(첨자)를 사용하여 원소에 직접 접근합니다.
    *   배열의 원소들은 컴퓨터 메모리의 **연속적인 기억장소**에 할당되어 순차적으로 저장됩니다.
    *   **배열 원소의 주소 계산**:
        *   배열 A의 시작 주소를 `BaseAddress`라 하고, 각 원소의 크기를 `ElementSize`라 가정할 때, `A[i]` (0부터 시작하는 인덱스 기준)의 저장 주소는 `BaseAddress + i * ElementSize`가 됩니다.
        *   (1부터 시작하는 인덱스 기준)의 저장 주소는 `BaseAddress + (i-1) * ElementSize`가 됩니다.
*   **2차원 배열**
    *   **정의**: 두 개의 첨자를 가지는 배열로, 동일한 크기의 1차원 배열을 모아 놓아 바둑판 형태로 구성됩니다.
    *   **구분**: 하나의 원소는 두 개의 첨자 `i` (행)와 `j` (열)의 쌍으로 구분됩니다: `A[i][j]`
        *   **행 (row)**: 첨자 `i`에 해당합니다.
        *   **열 (column)**: 첨자 `j`에 해당합니다.
    *   **저장 방식**: 2차원 배열은 메모리상에서 1차원으로 저장되어야 합니다.
        *   **열 우선 순서 저장 (Column-Major Order)**: 첫 열에 있는 각 행의 원소를 차례대로 메모리에 저장하고 다음 열로 이동하여 각 행에 있는 원소를 차례대로 저장하는 방법입니다. (주로 Fortran 등에서 사용)
        *   **행 우선 순서 저장 (Row-Major Order)**: 첫 행에 있는 각 열의 원소를 차례대로 메모리에 저장하고 다음 행으로 이동하여 각 열에 있는 원소를 차례대로 저장하는 방법입니다. (주로 C/C++, Java 등에서 사용)
*   **희소 행렬 (Sparse Matrix)**
    *   **정의**: 원소 값이 0인 원소가 0이 아닌 원소보다 상대적으로 많은 행렬입니다.
    *   **목적**: 0 값을 저장하기 위한 컴퓨터 메모리의 낭비를 막고, 처리 효율성을 높이기 위해 사용됩니다.
    *   **표현**: 0이 아닌 값만을 따로 모아서 저장하는 방법으로 구현됩니다.
        *   0이 아닌 각 원소를 `(행 번호, 열 번호, 원소값)`의 형태로 나타내어 배열이나 연결 리스트 등으로 표현할 수 있습니다. (예: 튜플(tuple) 리스트 형태)

---

### 3. 리스트 (List)

*   **순서 리스트 (Ordered List)**
    *   1개 이상의 원소들이 순서를 가지고 구성된 자료구조입니다.
    *   `A = (a1, a2, ..., an)`과 같이 표시하며, `ai`는 i번째 원소를 나타내고 `n`은 리스트의 크기가 됩니다.
    *   **삽입**: 원소를 삽입하기 위해서는 삽입될 위치 이후의 모든 원소들을 한 칸씩 뒤로 이동시켜야 합니다. 이 과정에서 많은 연산이 발생할 수 있습니다.
    *   **삭제**: 원소를 삭제한 후, 그 뒤에 있는 모든 원소들을 한 칸씩 앞으로 이동시켜야 합니다. 이 역시 많은 연산을 필요로 할 수 있습니다.
*   **선형 리스트 (Linear List) / 연결 리스트 (Linked List)**
    *   **개념**: 메모리상에 **연속적이지 않게** 저장된 노드들을 포인터를 통해 논리적으로 연결하여 구현되는 자료구조입니다. (앞서 배열을 이용한 순서 리스트와 구분됨)
    *   **노드 구성**: 각 노드는 적어도 두 종류의 필드를 가집니다.
        *   **데이터 필드 (Data Field)**: 원소 값을 저장합니다.
        *   **링크 필드 (Link Field)**: 다음(또는 이전) 노드의 주소를 저장하여 노드 간의 연결을 만듭니다.
*   **단일 연결 리스트 (Singly Linked List)**
    *   각 노드의 링크 필드가 **후행 노드**만을 가리킵니다.
    *   특정 노드의 후행 노드에는 쉽게 접근할 수 있지만, 선행 노드에 대한 접근은 헤드(첫) 노드부터 새로 시작해야 하는 단점이 있습니다.
*   **이중 연결 리스트 (Doubly Linked List)**
    *   각 노드의 첫 번째 링크는 후행 노드를 가리키고, 두 번째 링크는 **선행 노드**를 가리킵니다.
    *   특정 노드에서 후행 노드뿐만 아니라 선행 노드에 대한 접근도 쉽게 제공하여 양방향 탐색이 가능합니다.
*   **순환 연결 리스트 (Circular Linked List) (보충)**
    *   마지막 노드의 링크가 `NULL` 대신 첫 번째(헤드) 노드를 가리켜 원형으로 연결된 리스트입니다.
    *   리스트의 시작과 끝이 없어 어느 노드에서든 리스트 전체를 탐색할 수 있는 장점이 있습니다.

---

### 4. 스택 (Stack)과 큐 (Queue)

#### 4.1 스택 (Stack)

*   **정의**: 데이터의 삽입(`Push`)과 삭제(`Pop`)가 **한쪽 끝 (Top)**에서만 이루어지는 자료구조입니다.
*   **특징**: 가장 나중에 입력된 데이터가 가장 먼저 제거되는 **후입선출 (LIFO: Last-In, First-Out)** 특징을 가집니다. (제공된 `FILO`는 `LIFO`의 다른 표현으로, `LIFO`가 더 보편적으로 사용됩니다.)
*   **주요 연산**:
    *   **Push**: 스택의 맨 위(Top)에 데이터를 삽입하는 연산입니다.
    *   **Pop**: 스택의 맨 위(Top)에 있는 데이터를 제거하고 반환하는 연산입니다.
    *   **Peek/Top**: 스택의 맨 위 데이터를 반환하되, 제거하지는 않는 연산입니다.
*   **스택 언더플로 (Underflow)**
    *   삭제 연산(`Pop`)을 수행할 때 스택에 데이터가 존재하지 않아 더 이상 삭제할 수 없는 현상입니다.

#### 4.2 큐 (Queue)

*   **정의**: 선형 리스트의 한쪽 끝(`Rear`, 뒤)에서는 데이터의 삽입만 이루어지고, 다른 한쪽 끝(`Front`, 앞)에서는 데이터의 삭제만 이루어지는 자료구조입니다.
*   **특징**: 가장 먼저 입력된 데이터가 가장 먼저 제거되는 **선입선출 (FIFO: First-In, First-Out)** 특징을 가집니다.
*   **주요 연산**:
    *   **Enqueue**: 큐의 뒤(`Rear`)에 데이터를 삽입하는 연산입니다.
    *   **Dequeue**: 큐의 앞(`Front`)에 있는 데이터를 제거하고 반환하는 연산입니다.
*   **오버플로 (Overflow)**
    *   삽입 연산(`Enqueue`)을 수행할 때 큐를 위해 할당된 저장 공간을 초과하여 더 이상 데이터를 삽입할 수 없는 현상입니다.
*   **언더플로 (Underflow)**
    *   삭제 연산(`Dequeue`)을 수행할 때 큐에 데이터가 존재하지 않아 더 이상 삭제할 수 없는 현상입니다.
*   **만원 상태 문제와 원형 큐 (Circular Queue) (보충)**
    *   일반적인 선형 큐에서는 `Rear` 변수가 큐의 마지막 인덱스(`n-1`)에 도달하면 큐 공간이 남아있더라도 더 이상 삽입할 수 없는 '만원'으로 판단될 수 있습니다. (실제 데이터는 Dequeue되어 비어있는 공간이 있을 수 있음)
    *   이를 해결하기 위해 **원형 큐**가 사용됩니다. 큐의 끝과 시작이 연결된 형태로, `Front`와 `Rear` 포인터가 배열의 양 끝에 도달하면 다시 배열의 시작으로 돌아가면서 공간을 재사용합니다. 이는 큐의 효율적인 공간 활용을 가능하게 합니다.